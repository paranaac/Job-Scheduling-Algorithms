/*******************************************************************
* Job Source
* CSCI511 Project 1
*
*                  *** DO NOT EDIT THIS FILE ***
* It is purposely written to compile and run in ANY version of Java
*
********************************************************************
* This file reads in a CSV containing job information.
* The default file is joblist.csv
* It then acts as a job source (not a job scheduler).
* To work one of the jobs, you call the cycle function, providing
* job ID to work on.
* Working on a job will automatically make the clock jump to the
* next cycle.
********************************************************************
* BASIC USE:
*
* First, create a job source:
*  Jobs jobsource = new Job();
* You can put a string in the constructor to use a custom name for
* your jobs csv file.
*
* Now, you want to get jobs and work on a job until the job source
* is done. Use the jobsource.done() function to cycle through the
* jobs until all of the jobs are complete:
*  while(!jobsource.done())
*  {
*    //Get the jobs waiting in the queue.
*    int[][] jobs = jobsource.getJobs();
*    //See below for how the jobs array is structured.
*
*    //Pick a job to work on here.
*    //Assume you want to work on job ID 3, you use:
*    jobsource.cycle(3);
*  }
*
* When jobsource.done() is true, you should get the report.
* The report is in CSV format. You can print it or save it to a
* file for future use.
*  String report = jobsource.report();
*
* Technically, you can run a report whenever you like, but it only
* makes sense when all jobs are complete.
********************************************************************
* JOB ARRAY
* When you use the getJobs() method, you will get an int array.
* Each element of the returned array is a job.
* Each job has three integer elements: {Job ID, Duration, Priority}
*  Job ID: This is the unique ID for this job, used in cycle().
*  Duration: This is how many cycles the job still needs to run.
*  Priority: This is the priority for the job such that the greater
*    the number, the higher the priority.
* If you call getJobs() and get an empty array, that means that
* there are no jobs waiting. This is possible even when done() is
* not true. Therefore, you may need to cycle without a job. You can
* cycle without a job by using:
*  jobsource.cycle();
********************************************************************/

/*** DO NOT EDIT THIS FILE ***/

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.NumberFormatException;

public class Jobs
{
	private int[] stas = new int[0];
	private int[] durs = new int[0];
	private int[] lefs = new int[0];
	private int[] pris = new int[0];
	private int[] fins = new int[0];
	private int clock;
	
	public Jobs()
	{
		this("joblist.csv");
	}
	
	public Jobs(String filename)
	{
		BufferedReader fp = null;
		String line = "";
		String[] b = null;
		int[] tmp;
		try
		{
			fp = new BufferedReader(new FileReader(filename));
			while((line = fp.readLine()) != null)
			{
				b = line.split(",");
				if(b.length == 3)
				{
					try
					{
						int sta = Integer.parseInt(b[0]);
						int dur = Integer.parseInt(b[1]);
						int pri = Integer.parseInt(b[2]);
						stas = app(stas, sta);
						durs = app(durs, dur);
						lefs = app(lefs, dur);
						pris = app(pris, pri);
						fins = app(fins, -1);
					}
					catch(NumberFormatException e) {}
				}
			}
			fp.close();
		}
		catch(FileNotFoundException e) { e.printStackTrace(); }
		catch(IOException e) { e.printStackTrace(); }
		clock = 0;
	}
	
	public boolean done()
	{
		boolean done = true;
		for(int i=0; done && i<lefs.length; i++)
			if(lefs[i]>0) done=false;
		return done;
	}
	
	public int getClock() { return clock; }
	public int[][] getJobs()
	{
		int count = 0;
		for(int i=0; i<stas.length; i++)
			if(stas[i]<=clock && lefs[i]>0)
				count++;
		int[][] jobs = new int[count][3];
		count = 0;
		for(int i=0; i<stas.length; i++)
			if(stas[i]<=clock && lefs[i]>0)
			{
				jobs[count] = new int[]{i, lefs[i], pris[i]};
				count++;
			}
		return jobs;
	}
	
	public int cycle() { return cycle(-1); }
	public int cycle(int j)
	{
		if(j>=0 && j<lefs.length && clock>=stas[j] && lefs[j]>0)
		{
			lefs[j]--;
			if(lefs[j] == 0) fins[j] = clock+1;
		}
		clock++;
		return clock;
	}
	
	private int[] app(int[] a, int b)
	{
		int[] tmp = new int[a.length+1];
		for(int i=0; i<a.length; i++) tmp[i] = a[i];
		tmp[a.length] = b;
		return tmp;
	}
	
	public String report()
	{
		String r = "JOB,PRIORITY,START,DURATION,FINISH,DELAY,PRI*DELAY\n";
		float dn=0;
		float pdn=0;
		for(int i=0; i<stas.length; i++)
		{
			if(fins[i]>=0)
			{
				int delay = ((fins[i]-stas[i])-durs[i]);
				r+= ""+i+","+pris[i]+","+stas[i]+","+durs[i]+","+fins[i]+","+delay+","+(pris[i]*delay)+"\n";
				dn+= delay;
				pdn+= pris[i]*delay;
			}
			else
			{
				int delay = ((clock*10-stas[i])-durs[i]);
				r+= ""+i+","+pris[i]+","+stas[i]+","+durs[i]+","+fins[i]+","+delay+","+(pris[i]*delay)+"\n";
				dn+= delay;
				pdn+= pris[i]*delay;
			}
		}
		if(stas.length>0)
		{
			r+= "Avg,,,,,"+(dn/stas.length)+","+pdn/stas.length+"\n";
		}
		return r;
	}
	
	public String toString()
	{
		String r = "There are "+stas.length+" jobs:\n";
		for(int i=0; i<stas.length; i++)
		{
			r+= "  JOB "+i+": START="+stas[i]+" DURATION="+durs[i]+" DURATION_LEFT="+lefs[i]+" PRIORITY="+pris[i]+"\n";
		}
		return r;
	}
}